{"message":"Not Found","documentation_url":"https://docs.github.com/rest/git/refs#get-all-references-in-a-namespace","status":"404","name":"ffcfccfcacfc","url":"http://223.70.92.38:28080/main-app/dashboard","showName":"test","appid":"com.test.pakeplus","icon":"","iconPath":"","iconRound":true,"state":true,"single":true,"injectJq":true,"tauriApi":false,"devbug":true,"version":"1.0.5","preview":"Android","platform":["1-1"],"width":915,"height":412,"desc":"","jsFile":[],"filterCss":"","customJs":"// very important, if you don't know what it is, don't touch it\n// 非常重要，不懂代码不要动，这里可以解决80%的问题，也可以生产1000+的bug\n\n/**\n * @description 安全跳转函数，针对 WebView 和微前端 iframe 优化\n * @param {string} url 目标 URL\n * @param {Window} targetWindow 目标 window 对象\n * @returns {void}\n */\nfunction safeNavigate(url, targetWindow) {\n    if (!url || typeof url !== 'string') {\n        console.warn('[safeNavigate] 无效的 URL:', url)\n        return\n    }\n    \n    // 使用顶层 window（跳出 iframe）\n    const win = targetWindow || window.top || window.parent || window\n    const isTopWindow = win === window\n    \n    console.log('[safeNavigate] 准备跳转:', url)\n    console.log('[safeNavigate] 使用 window:', isTopWindow ? '当前窗口' : '顶层窗口（已跳出 iframe）')\n    \n    // 使用异步方式确保在 WebView 中执行\n    setTimeout(() => {\n        console.log('[safeNavigate] 开始执行跳转')\n        \n        try {\n            win.location.href = url\n            console.log('[safeNavigate] ✓ 使用 location.href 跳转成功')\n        } catch (e) {\n            console.error('[safeNavigate] ✗ location.href 跳转失败:', e)\n        }\n    }, 10)\n}\n\n/**\n * @description 为指定 window 对象重写 window.open 并注册点击事件\n * @param {Window} targetWindow 要重写的 window 对象\n * @param {Document} targetDocument 目标 document 对象\n * @param {string} label 日志标签\n * @returns {boolean} 是否重写成功\n */\nfunction overrideWindowOpen(targetWindow, targetDocument, label) {\n    // 检查参数有效性\n    if (!targetWindow || !targetDocument) {\n        console.warn(`[overrideWindowOpen] targetWindow 或 targetDocument 为空，跳过`)\n        return false\n    }\n    \n    // 防止重复重写\n    if (targetWindow.__vcOpenOverridden) {\n        console.log(`[overrideWindowOpen] ${label} 已重写，跳过`)\n        return false\n    }\n    \n    try {\n        // 标记已重写\n        targetWindow.__vcOpenOverridden = true\n        \n        // 1. 重写 window.open\n        targetWindow.open = function (url, target, features) {\n            console.log(`[window.open ${label}] 被调用 ===>`, url)\n            \n            if (!url) {\n                console.warn(`[window.open ${label}] URL 为空`)\n                return null\n            }\n            \n            // 跳转到顶层窗口\n            safeNavigate(String(url), targetWindow.top || targetWindow.parent || targetWindow)\n            return targetWindow\n        }\n        \n        console.log(`[overrideWindowOpen] ✓ 已重写 ${label} 的 window.open`)\n        \n        // 2. 为 iframe 内部注册点击事件监听（关键！）\n        if (label !== 'main') {\n            targetDocument.addEventListener('click', (e) => {\n                const origin = e.target.closest('a')\n                const isBaseTargetBlank = targetDocument.querySelector('head base[target=\"_blank\"]')\n                \n                console.log(`[hookClick ${label}] origin:`, origin, 'isBaseTargetBlank:', isBaseTargetBlank)\n                \n                if (\n                    (origin && origin.href && origin.target === '_blank') ||\n                    (origin && origin.href && isBaseTargetBlank)\n                ) {\n                    e.preventDefault()\n                    e.stopPropagation() // 阻止事件冒泡\n                    console.log(`[hookClick ${label}] 拦截 iframe 内链接点击:`, origin.href)\n                    safeNavigate(origin.href, targetWindow.top || targetWindow.parent || targetWindow)\n                }\n            }, { capture: true })\n            \n            console.log(`[overrideWindowOpen] ✓ 已为 ${label} 注册点击事件`)\n        }\n        \n        return true\n    } catch (e) {\n        console.error(`[overrideWindowOpen] ✗ 重写 ${label} 失败:`, e)\n        return false\n    }\n}\n\n/**\n * @description 监听并处理所有 iframe（微前端架构核心）\n * @returns {object} 返回控制对象，包含 stop 方法用于清理资源\n */\nfunction hookAllIframes() {\n    console.log('[hookAllIframes] 开始监听 iframe')\n    \n    // 使用 WeakMap 追踪已处理的 iframe，避免重复处理\n    const processedIframes = new WeakMap()\n    let iframeCounter = 0\n    \n    // 处理已存在的 iframe\n    function processIframes() {\n        const iframes = document.querySelectorAll('iframe')\n        console.log('[hookAllIframes] 扫描到', iframes.length, '个 iframe')\n        \n        iframes.forEach((iframe) => {\n            try {\n                // 检查是否可以访问 contentWindow（排除跨域 iframe）\n                if (!iframe.contentWindow) {\n                    return\n                }\n                \n                // 尝试访问 contentDocument 来检测跨域\n                const canAccess = (() => {\n                    try {\n                        // 访问 contentDocument 会在跨域时抛出异常\n                        return !!iframe.contentDocument\n                    } catch (e) {\n                        return false\n                    }\n                })()\n                \n                if (!canAccess) {\n                    // 跨域 iframe 只记录一次\n                    if (!processedIframes.has(iframe)) {\n                        console.warn(`[hookAllIframes] iframe 跨域，无法注入`)\n                        processedIframes.set(iframe, 'cross-origin')\n                    }\n                    return\n                }\n                \n                // 检查是否已注册过（用于分配唯一 ID）\n                const alreadyRegistered = processedIframes.has(iframe)\n                \n                // 为新 iframe 分配 ID\n                let iframeId\n                if (alreadyRegistered) {\n                    iframeId = processedIframes.get(iframe)\n                    // 跳过错误状态和跨域状态\n                    if (iframeId === 'error' || iframeId === 'cross-origin') {\n                        return\n                    }\n                } else {\n                    iframeId = `iframe-${iframeCounter++}`\n                }\n                \n                // 处理 iframe 的函数\n                const injectToIframe = () => {\n                    if (!iframe.contentWindow || !iframe.contentDocument) {\n                        console.warn(`[hookAllIframes] ${iframeId} contentWindow 或 contentDocument 为空`)\n                        return false\n                    }\n                    \n                    // 检查是否需要重新注入（iframe 内部可能发生了路由跳转）\n                    const needsReinject = !iframe.contentWindow.__vcOpenOverridden\n                    \n                    if (needsReinject) {\n                        console.log(`[hookAllIframes] ${iframeId} 需要${processedIframes.has(iframe) ? '重新' : ''}注入`)\n                    }\n                    \n                    if (overrideWindowOpen(iframe.contentWindow, iframe.contentDocument, iframeId)) {\n                        processedIframes.set(iframe, iframeId)\n                        console.log(`[hookAllIframes] ✓ ${iframeId} 已完成注入`)\n                        return true\n                    }\n                    return false\n                }\n                \n                // 检查 iframe 是否已加载\n                if (iframe.contentDocument && iframe.contentDocument.readyState === 'complete') {\n                    // 已加载完成，立即重写\n                    injectToIframe()\n                } else {\n                    // 未加载完成，等待 load 事件\n                    processedIframes.set(iframe, 'loading')\n                }\n                \n                // 监听 iframe 的 load 事件（每次 iframe 导航都会触发）\n                // 注意：不使用 { once: true }，因为需要监听 iframe 内部的每次路由跳转\n                iframe.addEventListener('load', () => {\n                    console.log(`[hookAllIframes] ${iframeId} load 事件触发`)\n                    \n                    // 延迟注入，确保 iframe 内容完全加载\n                    setTimeout(() => {\n                        try {\n                            // 每次 load 都尝试重新注入（处理 iframe 内部路由跳转）\n                            // 如果已重写过，overrideWindowOpen 会自动跳过\n                            injectToIframe()\n                        } catch (e) {\n                            console.warn(`[hookAllIframes] ${iframeId} 注入失败:`, e.message)\n                        }\n                    }, 50)\n                })\n            } catch (e) {\n                // 捕获跨域等异常\n                console.warn(`[hookAllIframes] 处理 iframe 失败:`, e.message)\n                processedIframes.set(iframe, 'error')\n            }\n        })\n    }\n    \n    // 立即处理现有 iframe\n    processIframes()\n    \n    // 使用 MutationObserver 监听新增 iframe\n    const observer = new MutationObserver((mutations) => {\n        let hasNewIframe = false\n        \n        mutations.forEach((mutation) => {\n            mutation.addedNodes.forEach((node) => {\n                if (node.tagName === 'IFRAME') {\n                    hasNewIframe = true\n                } else if (node.querySelectorAll) {\n                    const iframes = node.querySelectorAll('iframe')\n                    if (iframes.length > 0) {\n                        hasNewIframe = true\n                    }\n                }\n            })\n        })\n        \n        if (hasNewIframe) {\n            console.log('[hookAllIframes] 检测到新 iframe，重新扫描')\n            processIframes()\n        }\n    })\n    \n    observer.observe(document.documentElement, {\n        childList: true,\n        subtree: true\n    })\n    \n    // 定时检查（检测 iframe 内部的路由变化）\n    const intervalId = setInterval(() => {\n        const iframes = document.querySelectorAll('iframe')\n        \n        iframes.forEach((iframe) => {\n            try {\n                // 检查是否可访问且需要重新注入\n                if (iframe.contentWindow && iframe.contentDocument) {\n                    const needsReinject = !iframe.contentWindow.__vcOpenOverridden\n                    \n                    if (needsReinject) {\n                        console.log('[hookAllIframes] 检测到 iframe 内部路由变化，重新扫描')\n                        processIframes()\n                        return // 只触发一次重新扫描\n                    }\n                }\n            } catch (e) {\n                // 跨域或其他异常，忽略\n            }\n        })\n    }, 2000) // 每 2 秒检查一次\n    \n    console.log('[hookAllIframes] ✓ 监听器已启动')\n    \n    // 返回控制对象，用于清理资源\n    return {\n        stop: () => {\n            observer.disconnect()\n            clearInterval(intervalId)\n            console.log('[hookAllIframes] ✓ 监听器已停止')\n        }\n    }\n}\n\n/**\n * @description 处理链接点击事件\n * @param {Event} e 点击事件对象\n */\nconst hookClick = (e) => {\n    const origin = e.target.closest('a')\n    const isBaseTargetBlank = document.querySelector(\n        'head base[target=\"_blank\"]'\n    )\n    console.log('[hookClick] origin:', origin, 'isBaseTargetBlank:', isBaseTargetBlank)\n    \n    if (\n        (origin && origin.href && origin.target === '_blank') ||\n        (origin && origin.href && isBaseTargetBlank)\n    ) {\n        e.preventDefault()\n        console.log('[hookClick] 拦截新标签页打开，目标:', origin.href)\n        safeNavigate(origin.href)\n    } else {\n        console.log('[hookClick] 不处理此点击')\n    }\n}\n\n// ========== 初始化 ==========\n\n// 1. 重写主应用的 window.open\noverrideWindowOpen(window, document, 'main')\n\n// 2. 监听点击事件\ndocument.addEventListener('click', hookClick, { capture: true })\n\n// 3. 启动 iframe 监听\nlet iframeHookController = null\n\nif (document.readyState === 'loading') {\n    document.addEventListener('DOMContentLoaded', () => {\n        iframeHookController = hookAllIframes()\n        console.log('[诊断] 页面 URL:', window.location.href)\n    })\n} else {\n    iframeHookController = hookAllIframes()\n    console.log('[诊断] 页面 URL:', window.location.href)\n}\n\nconsole.log('[初始化] ✓ 微前端跳转拦截已启动')\n\n// 可选：提供清理函数（用于调试或卸载）\nwindow.__vcCleanup = () => {\n    if (iframeHookController) {\n        iframeHookController.stop()\n    }\n    console.log('[清理] ✓ 已清理所有监听器')\n}\n\n","isHtml":false,"htmlPath":"","htmlFiles":[],"prefix":"","pcRepo":"PakePlus-v2.1.3","iosRepo":"PakePlus-iOS-v2.1.3","androidRepo":"PakePlus-Android-v2.1.3","more":{"windows":{"label":"ffcfccfcacfc","title":"test","url":"http://223.70.92.38:28080/main-app/dashboard","userAgent":"Mozilla/5.0 (Linux; Android 14; Pixel 6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/130.0.0.0 Mobile Safari/537.36","width":915,"height":412,"theme":null,"resizable":true,"fullscreen":false,"maximized":false,"minWidth":400,"minHeight":300,"maxWidth":1920,"maxHeight":1080,"decorations":true,"transparent":false,"titleBarStyle":"Visible","visible":true,"focus":true,"closable":true,"minimizable":true,"maximizable":true,"alwaysOnTop":false,"alwaysOnBottom":false,"center":false,"shadow":true,"skipTaskbar":false,"tabbingIdentifier":null,"parent":null,"dragDropEnabled":true,"browserExtensionsEnabled":false,"devtools":true,"contentProtected":false,"hiddenTitle":false,"incognito":false,"proxyUrl":null,"useHttpsScheme":false,"zoomHotkeysEnabled":false,"acceptFirstMouse":false,"create":false,"backgroundColor":null,"backgroundThrottling":null,"javascriptDisabled":false}},"phone":{"safeArea":{"top":0,"bottom":0,"left":0,"right":0},"header":{"show":false,"title":"","backgroundColor":"","color":"","fontSize":16,"fontWeight":"bold","loading":false,"toolBar":false,"toolBarBackgroundColor":"","toolBarColor":"","toolBarFontSize":16,"toolBarFontWeight":"bold"},"siderMenu":{"show":false,"width":0,"backgroundColor":"","color":"","fontSize":16,"fontWeight":"bold","title":"","titleColor":"","titleFontSize":16,"titleFontWeight":"bold"},"tabBar":{"show":false,"backgroundColor":"","color":"","activeColor":"","fontSize":16,"fontWeight":"bold","tabBarItem":[]},"webview":{"userAgent":"","javaScriptEnabled":true,"domStorageEnabled":true,"allowFileAccess":true,"loadWithOverviewMode":true,"setSupportZoom":true,"clearCache":true}},"ios":{"name":"ffcfccfcacfc","showName":"test","version":"1.0.5","webUrl":"http://223.70.92.38:28080/main-app/dashboard","id":"com.test.pakeplus.ios","icon":"./app-icon.png","desc":"Package for personal use only, please do not use for commercial purposes（打包仅限个人使用，请勿传播或商业用途）","pubBody":"Package for personal use only, please do not use for commercial purposes（打包仅限个人使用，请勿传播或商业用途）","isHtml":false,"debug":true,"safeArea":"all"},"android":{"name":"ffcfccfcacfc","showName":"test","version":"1.0.5","webUrl":"http://223.70.92.38:28080/main-app/dashboard","id":"com.test.pakeplus.android","icon":"./app-icon.png","input":"./app-icon.png","output":"./res","rounded":true,"copyTo":"./app/src/main/res","androidResDir":"./app/src/main/res","desc":"Package for personal use only, please do not use for commercial purposes（打包仅限个人使用，请勿传播或商业用途）","pubBody":"Package for personal use only, please do not use for commercial purposes（打包仅限个人使用，请勿传播或商业用途）","isHtml":false,"debug":true,"safeArea":"all"},"desktop":{"name":"ffcfccfcacfc","showName":"test","version":"1.0.5","id":"com.test.pakeplus.desktop","desc":"打包仅限个人使用，请勿传播或商业用途，否则后果自负","webUrl":"http://223.70.92.38:28080/main-app/dashboard","iconPath":"../app-icon.png","inputPath":"../app-icon.png","tempPath":"./processed-image.png","icnsPath":"../src-tauri/icons/icon.icns","pubBody":"打包仅限个人使用，请勿传播或商业用途，否则后果自负","isHtml":false,"single":true,"state":true,"injectJq":false,"tauriApi":false,"buildMethod":"local","debug":true}}